# Bellabeat Case Study
### SQL and Data Viz

## Scenario
You are a junior data analyst working on the marketing analyst team at Bellabeat, a high-tech manufacturer of health-focused products for women. Bellabeat is a successful small company, but they have the potential to become a larger player in the
global smart device market. Urška Sršen, cofounder and Chief Creative Officer of Bellabeat, believes that analyzing smart device fitness data could help unlock new growth opportunities for the company. You have been asked to focus on one of Bellabeat’s products and analyze smart device data to gain insight into how consumers are using their smart devices. The insights you discover will then help guide marketing strategy for the company. You will present your analysis to the Bellabeat executive team along with your high-level recommendations for Bellabeat’s marketing strategy.

**Primary stakeholders:** Bellabeat executive team (Urška Sršen, Sando Mur)
**Secondary stakeholders:** Bellabeat marketing analytics team

## Data Source
FitBit Fitness Tracker Data (CCO: Public Domain, dataset made available through Mobius).
Source: https://www.kaggle.com/datasets/arashnic/fitbit
THe description provided for this data set was: 
    "This dataset generated by respondents to a distributed survey via Amazon Mechanical Turk between 03.12.2016-05.12.2016. Thirty eligible Fitbit users consented to the submission of personal tracker data, including minute-level output for physical activity, heart rate, and sleep monitoring. Individual reports can be parsed by export session ID (column A) or timestamp (column B). Variation between output represents use of different types of Fitbit trackers and individual tracking behaviors / preferences."

HOWEVER, diving into the data set provided later revealed that the data set only contained data tracked from April 12 - May 12, 2016. Another issue with the data set was that 33 distinct IDs were found which suggested that the information came from 33 users instead of the stated 30 users. 

The data set had 18 CSV files.

## Data Exploration
I used BigQuery as the chosen dialect of SQL to explore the data. 

Prior to using BigQuery to explore the data, I loaded all 18 csv files into Excel to clean the data through checking for duplicates, null values, etc. Then I prepared them to be imported into BigQuery as tables.

Once all 18 csv files were imported into BigQuery, I first checked to make sure the date formatting stayed the same across the 18 tables. 

### Setting Things Up
```markdown
-- timestamp/date formatting stays the same across tables
-- Setting variables for regular expression based analyses
DECLARE TIMESTAMP_REGEX STRING DEFAULT 
  r'^\d{4}-\d{1,2}-\d{1,2}[T]\d{1,2}:\d{1,2}:\d{1,2}(\.\d{1,6})? *(([+-]\d{1,2}(:\d{1,2})?)|Z|UTC)?$';
DECLARE DATE_REGEX STRING DEFAULT 
  r'^\d{4}-(?:[1-9]|0[1-9]|1[012])-(?:[1-9]|0[1-9]|[12][0-9]|3[01])$';
DECLARE TIME_REGEX STRING DEFAULT 
  r'^\d{1,2}:\d{1,2}:\d{1,2}(\.\d{1,6})?$';
```
<br>
Then I wanted set the different times of day for later data exploration

```markdown
-- Setting variables for time of day/ day of week analyses
DECLARE MORNING_START, MORNING_END, AFTERNOON_END, EVENING_END INT64;
-- Set the times for the times of the day
SET MORNING_START = 6;
SET MORNING_END = 12;
SET AFTERNOON_END = 18;
SET EVENING_END = 21;
```
### 
I wanted to find which columns existed in more than one table in case, I wanted to JOIN any tables together for analysis later. BigQuery does not use primary and foreign keys (relational databases) but I wanted to find the "primary key". "Id" seemed like a the best fit. 
```markdown
-- Finding columns that exist in multiple tables
SELECT 
  table_name, column_name
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE table_catalog = 'tenacious-text-379818'
  AND table_schema = 'Capstone'
  AND table_name != 'daily_activity'
  AND column_name = 'Id';
```
<br>
Then I checked to see if the column 'Id' existed in all tables in the data set

```markdown
-- Checking if 'Id' exists in all tables in data set
SELECT 
  table_name,
  SUM(
    CASE WHEN column_name = "Id" THEN 1
    ELSE 0
    END
    ) AS has_id_column
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
GROUP BY 1
ORDER BY 1 ASC;
```
<br>
The data set was tracking users across a certain time period and so I checked if each table in the data set had a date or time column. I did this by see which tables did not have such a column.

```markdown
-- Checking that every column has date/time type. The result should be: empty if the columns were detected properly
SELECT table_name,
  SUM (CASE WHEN data_type IN ("TIMESTAMP", "DATETIME", "TIME", "DATE") THEN 1
    ELSE 0
    END
    ) AS has_time_info
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE data_type IN ("TIMESTAMP","DATETIME","DATE")
GROUP BY 1
HAVING has_time_info = 1;
```
<br>
For later reference, I wanted to find out the name of the date/time datatype columns in each table as this could affect the the data when comparing two different tables in the data set. For example, comparing a table that tracked by the minute or hour versus a table that tracked data by the day.

```markdown
-- Seeing the name of the time/date datatype column in each table
SELECT
  table_name,
  column_name
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE data_type IN ("TIMESTAMP","DATETIME","DATE");

-- Finding tables that have day|daily for daily data
SELECT DISTINCT table_name
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE REGEXP_CONTAINS(LOWER(table_name),"day|daily");
```

<br>
I wanted to look at the data that was tracked daily and so sought to find day/daily columns and see the count of the occurences of such tables for each unique combination of column name and data type.

```markdown
-- Finding the frequency of occurence of the columns in the day|daily tables
SELECT 
  column_name, 
  data_type,
  COUNT(table_name) AS table_count
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE REGEXP_CONTAINS(LOWER(table_name), r'day|daily')
GROUP BY 1, 2;
```
<br>
Then to go a step further and filter the columns that contain day/daily that also occur in at least 2 different tables.

```markdown
-- Filtering columns that contain 'day|daily' that also occur in at least 2 different tables
SELECT
  column_name,
  table_name,
  data_type
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE REGEXP_CONTAINS(LOWER(table_name), r'day|daily')
  AND column_name IN (
    SELECT column_name
    FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
    WHERE REGEXP_CONTAINS(LOWER(table_name),r'day|daily')
    GROUP BY 1
    HAVING COUNT(table_name) >= 2
    )
ORDER BY 1;
```
### Merging the Data Across Different Tables for Analysis
Now I was ready to JOIN the tables with day/daily columns to create a table for further analysis. Since I wanted to create one table for analysis, I had to join together different tables together. I named the combined table: 'daily_merged_01'.

```markdown
-- Joined (LEFT JOIN) the filtered tables: daily_activity, daily_calories, daily_intensities, daily_steps, daily_sleep
SELECT
  A.Id,
  A.Calories,
  * EXCEPT(Id,
  Calories,
  ActivityDay,
  SedentaryMinutes,
  LightlyActiveMinutes,
  FairlyActiveMinutes,
  VeryActiveMinutes,
  SedentaryActiveDistance,
  LightActiveDistance,
  ModeratelyActiveDistance,
  VeryActiveDistance
  ),
  I.SedentaryMinutes,
  I.LightlyActiveMinutes,
  I.FairlyActiveMinutes,
  I.VeryActiveMinutes,
  I.SedentaryActiveDistance,
  I.LightActiveDistance,
  I.ModeratelyActiveDistance,
  I.VeryActiveDistance
FROM `tenacious-text-379818.Capstone.daily_activity` A
LEFT JOIN `tenacious-text-379818.Capstone.daily_calories` C
  ON
    A.Id = C.Id
    AND A.ActivityDate=C.ActivityDay
    AND A.Calories = C.Calories
LEFT JOIN `tenacious-text-379818.Capstone.daily_intensities` I
  ON
    A.Id = I.Id
    AND A.ActivityDate=I.ActivityDay
    AND A.FairlyActiveMinutes = I.FairlyActiveMinutes
    AND A.LightActiveDistance = I.LightActiveDistance
    AND A.LightlyActiveMinutes = I.LightlyActiveMinutes
    AND A.ModeratelyActiveDistance = I.ModeratelyActiveDistance
    AND A.SedentaryActiveDistance = I.SedentaryActiveDistance
    AND A.SedentaryMinutes = I.SedentaryMinutes
    AND A.VeryActiveDistance = I.VeryActiveDistance
    AND A.VeryActiveMinutes = I.VeryActiveMinutes
LEFT JOIN `tenacious-text-379818.Capstone.daily_steps` S
  ON
    A.Id = S.Id
    AND DATE(A.ActivityDate) = DATE(S.ActivityDay)
LEFT JOIN `tenacious-text-379818.Capstone.daily_sleep` S1
  ON
    A.Id = S1.Id
    AND DATE(A.ActivityDate) = DATE(S1.SleepDay);
```
### Finding the Real Parameters of the Data Set
The data set was described to be data tracked over a one month period but I wanted to double check. I found out that the data was tracked over 31 days from April 12 to May 12, 2016. 

```markdown
-- Finding start (2016.04.12) and end date (2016.05.12), to find the duration over which the data was tracked
SELECT
  MIN(ActivityDate) AS earliest_date,
  MAX(ActivityDate) AS latest_date,
  DATE_DIFF(
  CAST(MAX(ActivityDate) AS DATETIME),
  CAST(MIN(ActivityDate) AS DATETIME),
  DAY) +1 AS number_of_days
FROM `tenacious-text-379818.Capstone.daily_merged_01`
```
<br>

As it appeared that the description didn't align with the data, I proceeded to verify whether there were genuinely 30 distinct IDs as indicated in the dataset's description for the supposed 30 users. Turns out there were actually 33 distinct Ids. And so now instead of 30 users across a 2 month period, I was really dealing with 33 users across a one month period. Then I wanted to how many groups of users were there based on the frequency of their tracked data. 
```markdown
-- Finding the count of occurence for each distinct 'Total_Id' (num of days) value in the daily_merged_01 table
WITH user_counts AS (
  SELECT
  Id,
  COUNT(DISTINCT DATE(ActivityDate)) AS CountDays
  FROM `tenacious-text-379818.Capstone.daily_merged_01`
  GROUP BY Id
  )
SELECT
  CountDays,
  COUNT(DISTINCT Id) AS UserCount,
  ROUND((COUNT(DISTINCT Id) / (SELECT COUNT(DISTINCT Id) FROM user_counts)) * 100, 2) AS UserPercentage,
  ROUND((CountDays / 31.0) * 100, 2) AS DaysPercentage
FROM user_counts
GROUP BY CountDays
ORDER BY CountDays DESC;
```
<img src="Graphs & Charts/Number of users per days of tracked data.png" alt="Users by Frequency of Tracked Data" />

### Grouping the Users
I aimed to categorize the 33 distinct users based on the frequency of their recorded data. Given that Fitbit is a wearable device that captures data, I considered that the frequency of days with entered data could serve as an indicator of how frequently they utilized their Fitbit. I decided to put the users into 3 groups, those who had data every single day of the 31 days, those who only missed up 1-3 days, and those that missed 4 days or more. 

```markdown
-- Grouped the users by the number of days that they had a data entry
SELECT
  CASE WHEN CountDays = 31 
    THEN 'Group 1: 100% (31/31 days)'
    WHEN CountDays <= 28 
      THEN 'Group 2: >90% (at least 28/31 days)'
    ELSE 'Group 3: <90% (26 days or less)>'
  END AS Category,
  COUNT(*) AS UserCount
FROM 
  (
  SELECT Id, COUNT(DISTINCT DATE(ActivityDate)) AS CountDays
  FROM `tenacious-text-379818.Capstone.daily_merged_01`
  GROUP BY Id
  )
GROUP BY Category
ORDER BY Category
```

### Looking at user step count (TotalSTeps) entries
I wanted to look at overall step count as the main source of activity since walking is something we all do. I also felt that step count provides a general picture of a user's overall activity levels. While not perfect since there are exercises that won't contribute to step count but yet are incredibly beneficial such as lifting weights or swimming. While there are also other actitivies that a high level of step count and yet are not as time efficient as an exercise as other forms of exercise such as golf compared to HIIT(high-intensity interval training). 

```markdown
-- How many of those that have entries for the entire 31 days also have entries for sleep (missing 5)

WITH user_counts AS (
  SELECT
  Id,
  COUNT(DISTINCT DATE(ActivityDate)) AS CountDays
  FROM `tenacious-text-379818.Capstone.daily_merged_01`
  GROUP BY Id
  ),
  users_with_countdays AS (
    SELECT
    uc.Id,
    dm.TotalSteps
    FROM user_counts uc
    JOIN `tenacious-text-379818.Capstone.daily_merged_01` dm
    ON uc.Id = dm.Id
    WHERE uc.CountDays = 31
    AND dm.TotalSteps IS NOT NULL
    ),
  users_without_entry AS (
    SELECT
    uc.Id
    FROM users_with_countdays uc 
    LEFT JOIN `tenacious-text-379818.Capstone.daily_sleep` ds
    ON uc.Id = ds.Id
    WHERE ds.Id IS NULL
    )
SELECT
  COUNT(*) AS Count,
  uw.Id
FROM users_without_entry uw
GROUP BY uw.Id;
```

<br>
I considered using "Sleep" table data to look at any correlation between sleep and any of the activity data. However, there were quite a number of users who wore their Fitbit everyday and yet did not have sleep data. This makes sense when considering health wearables generally needed to be charged at least once a day. In the group of users that had data for everyday of the 31 day period, 16 had had data for sleep and 5 did not. Since number of users for this dataset is low, 5 users, without sleep data, made up almost 1/3 of the group. Overall, for the 33 users in the data set, around 70% (72.73%) had data for sleep and almost 30% (27.27%) did not. So I wanted to break down the users in the Sleep table to see which of the participation of the three different groups in tracking sleep data.

```markdown
-- Looking at the relationship between the incomplete daily_sleep table and from which of the 3 groups the Ids are coming from
SELECT 
  ds.Id,
  CASE
    WHEN g1.Id IS NOT NULL THEN 'Group 1: 100%'
    WHEN g2.Id IS NOT NULL THEN 'Group 2: >90% (28-30 days)'
    WHEN g3.Id IS NOT NULL THEN 'Group 3: <90% (26 days or less)'
    ELSE 'Not in any group'
    END AS GroupCategory
FROM (SELECT DISTINCT Id FROM Capstone.daily_sleep) ds
LEFT JOIN tenacious-text-379818.Capstone.group1_31days g1 ON ds.Id = g1.Id
LEFT JOIN tenacious-text-379818.Capstone.group2_28to30days g2 ON ds.Id = g2.Id
LEFT JOIN tenacious-text-379818.Capstone.group3_less27days g3 ON ds.Id = g3.Id
GROUP BY ds.Id, GroupCategory
ORDER BY GroupCategory;
```
<br>
<img src="Graphs & Charts/Users broken into 3 groups based on data frequency.png" alt="User Groups based on data frequency" />

<br>

Looking at how many of users in the 3 groups have sleep data. 
```markdown
-- Aggregating the distinct Ids in the 3 groups  and counting how Ids have daily_sleep entry and how many don't
SELECT
  Group 1: 100%' AS group_name,
  COUNT(DISTINCT CASE WHEN ds.id IS NOT NULL THEN gs1.id END) AS count_with_entry,
  COUNT(DISTINCT CASE WHEN ds.id IS NULL THEN gs1.id END) AS count_without_entry
FROM Capstone.group1_31days gs1
LEFT JOIN Capstone.daily_sleep ds 
  ON gs1.id = ds.id
UNION ALL
SELECT
  Group 2: >90%' AS group_name,
  COUNT(DISTINCT CASE WHEN ds.id IS NOT NULL THEN gs2.id END) AS count_with_entry,
  COUNT(DISTINCT CASE WHEN ds.id IS NULL THEN gs2.id END) AS count_without_entry
FROM Capstone.group2_28to30days gs2
LEFT JOIN Capstone.daily_sleep ds 
  ON gs2.id = ds.id
UNION ALL
SELECT
  Group 3: <90%' AS group_name,
  COUNT(DISTINCT CASE WHEN ds.id IS NOT NULL THEN gs3.id END) AS count_with_entry,
  COUNT(DISTINCT CASE WHEN ds.id IS NULL THEN gs3.id END) AS count_without_entry
FROM Capstone.group3_less27days gs3
LEFT JOIN Capstone.daily_sleep ds 
  ON gs3.id = ds.id;
```
<br>
<img src= "Graphs & Charts/Users who also have sleep data.png">
<br>
<br>

### Relationship between average daily calories and daily steps
For each other 3 groups, I wanted to see if there any trends amongst the 3 groups that were different from the others when it came to the relationship between daily calories and daily steps. Turns out there was not. This could be due to having a wearable tech tracking user activity encourages the user to be more fit. 

```markdown
-- Average calories and steps for the 3 groups
-- Calculate the average of Calories and TotalSteps for group1_31days
SELECT 
  AVG(Calories) AS Average_Calories, 
  AVG(TotalSteps) AS Average_TotalSteps
FROM Capstone.group1_31days
UNION ALL
-- Calculate the average of Calories and TotalSteps for group2_28to30days
SELECT 
  AVG(Calories) AS Average_Calories, 
  AVG(TotalSteps) AS Average_TotalSteps
FROM Capstone.group2_28to30days
UNION ALL
-- Calculate the average of Calories and TotalSteps for group3_less27days
SELECT 
  AVG(Calories) AS Average_Calories, 
  AVG(TotalSteps) AS Average_TotalSteps
FROM Capstone.group3_less27days;
```

### Analyzing the 100% Completion Group: Exploring the Connection Between Daily Steps and Activity Levels
Wanted to see the average steps for group 1, wore Fitbit for the entire month, for each day of the week. 
<br>

According to a 2001 CDC, Center for Disease Control, [article](https://www.cdc.gov/media/releases/2020/p0324-daily-step-count.html), NIA (National Institute for Aging) and NCI (National Cancer Institute) found in a study that people who took at least 8,000 steps were at a 51% chance lower risk, while those that took at least 12,000 steps per day were at a 65% chance lower risk from all-cause mortality compared with those who only took 4,000 steps4. 
<br>
<br>
So I thought that looking at step count would be a great indicator of health even though there is not a direct causation bewteen steps and reduced risk from all-cause mortality.


```markdown
-- Average step count for group1 throughout the week by day
SELECT
  FORMAT_TIMESTAMP('%A', ActivityDate) AS DayOfWeek,
  AVG(TotalSteps) AS AverageSteps
FROM `tenacious-text-379818.Capstone.group1_31days`
GROUP BY DayOfWeek
ORDER BY DayOfWeek;
```
<br>
<img src = "Graphs & Charts/Daily average steps for group 1 users.png">

<br>
<br>
Now I wanted to look at the relationship bewteen calories and total steps for group 1 on a daily basis. Looking 

```markdown
-- Looking at calories and total steps
SELECT
  Id,
  AVG(TotalSteps) AS average_steps,
  AVG(Calories) AS average_calories
FROM `tenacious-text-379818.Capstone.group1_31days`
GROUP BY Id
```
<br>

There was a correlation observed, but not a causal relationship, between the daily number of steps taken by users and their daily average calorie burn. This may be attributable to users occasionally removing their FitBit during exercise. Although the Fitbit is suitable for most situations, there are activities, like swimming, or situations where step counting is not feasible, such as cycling. This illustrates that while step counts can provide insight into a user's daily activity, they do not provide a complete picture.
<img src = "Graphs & Charts/Average Calories and Steps for Group 1 Users.png">

<br>
I observed that most users in this group consistently exceeded 8,000 daily steps, indicating prolonged Fitbit usage throughout the day. To investigate this further, I analyzed hourly step counts across the week, calculating average step counts for each hour throughout the day. 

```markdown
-- Hourly average step count by day for group 1
WITH hourly_avg AS (
  SELECT
    FORMAT_TIMESTAMP('%A', hs.ActivityHour) AS DayOfWeek,
    EXTRACT(HOUR FROM hs.ActivityHour) AS HourOfDay,
    AVG(hs.StepTotal) AS AverageHourlySteps
  FROM `Capstone.hourly_steps` hs
  LEFT JOIN `Capstone.group1_31days` g 
    ON hs.Id = g.Id
  GROUP BY 
    DayOfWeek,
    HourOfDay
  )
SELECT
  HourOfDay,
  AVG(IF(DayOfWeek = 'Monday', AverageHourlySteps, NULL)) AS Monday,
  AVG(IF(DayOfWeek = 'Tuesday', AverageHourlySteps, NULL)) AS Tuesday,
  AVG(IF(DayOfWeek = 'Wednesday', AverageHourlySteps, NULL)) AS Wednesday,
  AVG(IF(DayOfWeek = 'Thursday', AverageHourlySteps, NULL)) AS Thursday,
  AVG(IF(DayOfWeek = 'Friday', AverageHourlySteps, NULL)) AS Friday,
  AVG(IF(DayOfWeek = 'Saturday', AverageHourlySteps, NULL)) AS Saturday,
  AVG(IF(DayOfWeek = 'Sunday', AverageHourlySteps, NULL)) AS Sunday
FROM hourly_avg
GROUP BY HourOfDay
ORDER BY HourOfDay
```
<br>
<img src = "Graphs & Charts/Average Step Count by hour and day for Group 1.png">