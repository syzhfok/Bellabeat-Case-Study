# Bellabeat Case Study
##### SQL and Data Viz

## Scenario
You are a junior data analyst working on the marketing analyst team at Bellabeat, a high-tech manufacturer of health-focused products for women. Bellabeat is a successful small company, but they have the potential to become a larger player in the
global smart device market. Urška Sršen, cofounder and Chief Creative Officer of Bellabeat, believes that analyzing smart device fitness data could help unlock new growth opportunities for the company. You have been asked to focus on one of Bellabeat’s products and analyze smart device data to gain insight into how consumers are using their smart devices. The insights you discover will then help guide marketing strategy for the company. You will present your analysis to the Bellabeat executive team along with your high-level recommendations for Bellabeat’s marketing strategy.

** Primary stakeholders:** Bellabeat executive team (Urška Sršen, Sando Mur)
** Secondary stakeholders:** Bellabeat marketing analytics team

## Data Source
FitBit Fitness Tracker Data (CCO: Public Domain, dataset made available through Mobius).
Source: https://www.kaggle.com/datasets/arashnic/fitbit
THe description provided for this data set was: 
    "This dataset generated by respondents to a distributed survey via Amazon Mechanical Turk between 03.12.2016-05.12.2016. Thirty eligible Fitbit users consented to the submission of personal tracker data, including minute-level output for physical activity, heart rate, and sleep monitoring. Individual reports can be parsed by export session ID (column A) or timestamp (column B). Variation between output represents use of different types of Fitbit trackers and individual tracking behaviors / preferences."

HOWEVER, diving into the data set provided later revealed that the data set only contained data tracked from April 12 - May 12, 2016. Another issue with the data set was that 33 distinct IDs were found which suggested that the information came from 33 users instead of the stated 30 users. 

The data set had 18 CSV files.

## Data Exploration
I used BigQuery as the chosen dialect of SQL to explore the data. 

Prior to using BigQuery to explore the data, I loaded all 18 csv files into Excel to clean the data through checking for duplicates, null values, etc. Then I prepared them to be imported into BigQuery as tables.

Once all 18 csv files were imported into BigQuery, I first checked to make sure the date formatting stayed the same across the 18 tables. 

```markdown
-- timestamp/date formatting stays the same across tables
-- Setting variables for regular expression based analyses
DECLARE TIMESTAMP_REGEX STRING DEFAULT r'^\d{4}-\d{1,2}-\d{1,2}[T]\d{1,2}:\d{1,2}:\d{1,2}(\.\d{1,6})? *(([+-]\d{1,2}(:\d{1,2})?)|Z|UTC)?$';
DECLARE DATE_REGEX STRING DEFAULT r'^\d{4}-(?:[1-9]|0[1-9]|1[012])-(?:[1-9]|0[1-9]|[12][0-9]|3[01])$';
DECLARE TIME_REGEX STRING DEFAULT r'^\d{1,2}:\d{1,2}:\d{1,2}(\.\d{1,6})?$';
```

Then I wanted set the different times of day for later data exploration
```markdown
-- Setting variables for time of day/ day of week analyses
DECLARE MORNING_START, MORNING_END, AFTERNOON_END, EVENING_END INT64;

-- Set the times for the times of the day
SET MORNING_START = 6;
SET MORNING_END = 12;
SET AFTERNOON_END = 18;
SET EVENING_END = 21;
```

I wanted to find which columns existed in more than one table in case, I wanted to JOIN any tables together for analysis later. BigQuery does not use primary and foreign keys (relational databases) but I wanted to find the "primary key". "Id" seemed like a the best fit. 
```markdown
-- Finding columns that exist in multiple tables
SELECT 
  table_name, column_name
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE table_catalog = 'tenacious-text-379818'
  AND table_schema = 'Capstone'
  AND table_name != 'daily_activity'
  AND column_name = 'Id';
```

Then I checked to see if the column 'Id' existed in all tables in the data set
```markdown
-- Checking if 'Id' exists in all tables in data set
SELECT 
  table_name,
  SUM(
    CASE WHEN column_name = "Id" THEN 1
    ELSE 0
    END
    ) AS has_id_column
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
GROUP BY 1
ORDER BY 1 ASC;
```

The data set was tracking users across a certain time period and so I checked if each table in the data set had a date or time column. I did this by see which tables did not have such a column.
```markdown
-- Checking that every column has date/time type. The result should be: empty if the columns were detected properly
SELECT table_name,
  SUM (CASE WHEN data_type IN ("TIMESTAMP", "DATETIME", "TIME", "DATE") THEN 1
    ELSE 0
    END
    ) AS has_time_info
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE data_type IN ("TIMESTAMP","DATETIME","DATE")
GROUP BY 1
HAVING has_time_info = 1;
```

For later reference, I wanted to find out the name of the date/time datatype columns in each table as this could affect the the data when comparing two different tables in the data set. For example, comparing a table that tracked by the minute or hour versus a table that tracked data by the day.
```markdown
-- Seeing the name of the time/date datatype column in each table
SELECT
  table_name,
  column_name
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE data_type IN ("TIMESTAMP","DATETIME","DATE");

-- Finding tables that have day|daily for daily data
SELECT DISTINCT table_name
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE REGEXP_CONTAINS(LOWER(table_name),"day|daily");
```

I wanted to look at the data that was tracked daily and so sought to find day/daily columns and see the count of the occurences of such tables for each unique combination of column name and data type.
```markdown
-- Finding the frequency of occurence of the columns in the day|daily tables
SELECT 
  column_name, 
  data_type,
  COUNT(table_name) AS table_count
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE REGEXP_CONTAINS(LOWER(table_name), r'day|daily')
GROUP BY 1, 2;
```

Then to go a step further and filter the columns that contain day/daily that also occur in at least 2 different tables.
```markdown
-- Filtering columns that contain 'day|daily' that also occur in at least 2 different tables
SELECT
  column_name,
  table_name,
  data_type
FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
WHERE REGEXP_CONTAINS(LOWER(table_name), r'day|daily')
  AND column_name IN (
    SELECT column_name
    FROM `tenacious-text-379818.Capstone.INFORMATION_SCHEMA.COLUMNS`
    WHERE REGEXP_CONTAINS(LOWER(table_name),r'day|daily')
    GROUP BY 1
    HAVING COUNT(table_name) >= 2
    )
ORDER BY 1;
```

Now I was ready to JOIN the tables with day/daily columns to create a table for further analysis. Since I wanted to create one table for analysis, I had to join together different tables together. I named the combined table: 'daily_merged_01'.
```markdown
-- Joined (LEFT JOIN) the filtered tables: daily_activity, daily_calories, daily_intensities, daily_steps, daily_sleep
SELECT
  A.Id,
  A.Calories,
  * EXCEPT(Id,
  Calories,
  ActivityDay,
  SedentaryMinutes,
  LightlyActiveMinutes,
  FairlyActiveMinutes,
  VeryActiveMinutes,
  SedentaryActiveDistance,
  LightActiveDistance,
  ModeratelyActiveDistance,
  VeryActiveDistance
  ),
  I.SedentaryMinutes,
  I.LightlyActiveMinutes,
  I.FairlyActiveMinutes,
  I.VeryActiveMinutes,
  I.SedentaryActiveDistance,
  I.LightActiveDistance,
  I.ModeratelyActiveDistance,
  I.VeryActiveDistance
FROM `tenacious-text-379818.Capstone.daily_activity` A
LEFT JOIN `tenacious-text-379818.Capstone.daily_calories` C
  ON
    A.Id = C.Id
    AND A.ActivityDate=C.ActivityDay
    AND A.Calories = C.Calories
LEFT JOIN `tenacious-text-379818.Capstone.daily_intensities` I
  ON
    A.Id = I.Id
    AND A.ActivityDate=I.ActivityDay
    AND A.FairlyActiveMinutes = I.FairlyActiveMinutes
    AND A.LightActiveDistance = I.LightActiveDistance
    AND A.LightlyActiveMinutes = I.LightlyActiveMinutes
    AND A.ModeratelyActiveDistance = I.ModeratelyActiveDistance
    AND A.SedentaryActiveDistance = I.SedentaryActiveDistance
    AND A.SedentaryMinutes = I.SedentaryMinutes
    AND A.VeryActiveDistance = I.VeryActiveDistance
    AND A.VeryActiveMinutes = I.VeryActiveMinutes
LEFT JOIN `tenacious-text-379818.Capstone.daily_steps` S
  ON
    A.Id = S.Id
    AND DATE(A.ActivityDate) = DATE(S.ActivityDay)
LEFT JOIN `tenacious-text-379818.Capstone.daily_sleep` S1
  ON
    A.Id = S1.Id
    AND DATE(A.ActivityDate) = DATE(S1.SleepDay);
```

The data set was described to be data tracked over a one month period but I wanted to double check. I found out that the data was tracked over 31 days from April 12 to May 12, 2016. 
```markdown
-- Finding start (2016.04.12) and end date (2016.05.12), to find the duration over which the data was tracked
SELECT
  MIN(ActivityDate) AS earliest_date,
  MAX(ActivityDate) AS latest_date,
  DATE_DIFF(
  CAST(MAX(ActivityDate) AS DATETIME),
  CAST(MIN(ActivityDate) AS DATETIME),
  DAY) +1 AS number_of_days
FROM `tenacious-text-379818.Capstone.daily_merged_01`
```

As it appeared that the description didn't align with the data, I proceeded to verify whether there were genuinely 30 distinct IDs as indicated in the dataset's description for the supposed 30 users. Turns out there were actually 33 distinct Ids. And so now instead of 30 users across a 2 month period, I was really dealing with 33 users across a one month period. Then I wanted to how many groups of users were there based on the frequency of their tracked data. 
```markdown
-- Finding the count of occurence for each distinct 'Total_Id' (num of days) value in the daily_merged_01 table
WITH user_counts AS (
  SELECT
  Id,
  COUNT(DISTINCT DATE(ActivityDate)) AS CountDays
  FROM `tenacious-text-379818.Capstone.daily_merged_01`
  GROUP BY Id
  )
SELECT
  CountDays,
  COUNT(DISTINCT Id) AS UserCount,
  ROUND((COUNT(DISTINCT Id) / (SELECT COUNT(DISTINCT Id) FROM user_counts)) * 100, 2) AS UserPercentage,
  ROUND((CountDays / 31.0) * 100, 2) AS DaysPercentage
FROM user_counts
GROUP BY CountDays
ORDER BY CountDays DESC;
```

I aimed to categorize the 33 distinct users based on the frequency of their recorded data. Given that Fitbit is a wearable device that captures data, I considered that the frequency of days with entered data could serve as an indicator of how frequently they utilized their Fitbit.
```markdown
-- Grouped the users by the number of days that they had a data entry
SELECT
  CASE WHEN CountDays = 31 
    THEN 'Group 1: 100% (31/31 days)'
    WHEN CountDays <= 28 
      THEN 'Group 2: >90% (at least 28/31 days)'
    ELSE 'Group 3: <90% (26 days or less)>'
  END AS Category,
  COUNT(*) AS UserCount
FROM 
  (
  SELECT Id, COUNT(DISTINCT DATE(ActivityDate)) AS CountDays
  FROM `tenacious-text-379818.Capstone.daily_merged_01`
  GROUP BY Id
  )
GROUP BY Category
ORDER BY Category
```
![image](Graphs & Charts/Number of users per days of tracked data.png)

```markdown
-- How many of those that have entries for the entire 31 days also have entries for sleep (missing 5)

WITH user_counts AS (
  SELECT
  Id,
  COUNT(DISTINCT DATE(ActivityDate)) AS CountDays
  FROM `tenacious-text-379818.Capstone.daily_merged_01`
  GROUP BY Id
  ),
  users_with_countdays AS (
    SELECT
    uc.Id,
    dm.TotalSteps
    FROM user_counts uc
    JOIN `tenacious-text-379818.Capstone.daily_merged_01` dm
    ON uc.Id = dm.Id
    WHERE uc.CountDays = 31
    AND dm.TotalSteps IS NOT NULL
    ),
  users_without_entry AS (
    SELECT
    uc.Id
    FROM users_with_countdays uc
    LEFT JOIN `tenacious-text-379818.Capstone.daily_sleep` ds
    ON uc.Id = ds.Id
    WHERE ds.Id IS NULL
    )
SELECT
  COUNT(*) AS Count,
  uw.Id
FROM users_without_entry uw
GROUP BY uw.Id;
```


```markdown
-- Grouped the users in 3 groups based upon they have 100%, at least 90%, and less than 90% of the days of daily data
CREATE TABLE Capstone.group3_less27days AS
SELECT *
FROM `tenacious-text-379818.Capstone.daily_merged_01`
WHERE Id IN (
  SELECT Id
  FROM (
    SELECT Id, COUNT(DISTINCT DATE(ActivityDate)) AS CountDays
    FROM `tenacious-text-379818.Capstone.daily_merged_01`
    GROUP BY Id
    HAVING CountDays <= 27
    ) AS Group2
   )
```

```markdown
-- Looking at the relationship between the incomplete daily_sleep table and from which of the 3 groups the Ids are coming from
SELECT 
  ds.Id,
  CASE
    WHEN g1.Id IS NOT NULL THEN 'Group 1: 100%'
    WHEN g2.Id IS NOT NULL THEN 'Group 2: >90% (28-30 days)'
    WHEN g3.Id IS NOT NULL THEN 'Group 3: <90% (26 days or less)'
    ELSE 'Not in any group'
    END AS GroupCategory
FROM (SELECT DISTINCT Id FROM Capstone.daily_sleep) ds
LEFT JOIN tenacious-text-379818.Capstone.group1_31days g1 ON ds.Id = g1.Id
LEFT JOIN tenacious-text-379818.Capstone.group2_28to30days g2 ON ds.Id = g2.Id
LEFT JOIN tenacious-text-379818.Capstone.group3_less27days g3 ON ds.Id = g3.Id
GROUP BY ds.Id, GroupCategory
ORDER BY GroupCategory;
```


```markdown
-- Aggregating the distinct Ids in the 3 groups  and counting how Ids have daily_sleep entry and how many don't
SELECT
  Group 1: 100%' AS group_name,
  COUNT(DISTINCT CASE WHEN ds.id IS NOT NULL THEN gs1.id END) AS count_with_entry,
  COUNT(DISTINCT CASE WHEN ds.id IS NULL THEN gs1.id END) AS count_without_entry
FROM Capstone.group1_31days gs1
LEFT JOIN Capstone.daily_sleep ds 
  ON gs1.id = ds.id
UNION ALL
SELECT
  Group 2: >90%' AS group_name,
  COUNT(DISTINCT CASE WHEN ds.id IS NOT NULL THEN gs2.id END) AS count_with_entry,
  COUNT(DISTINCT CASE WHEN ds.id IS NULL THEN gs2.id END) AS count_without_entry
FROM Capstone.group2_28to30days gs2
LEFT JOIN Capstone.daily_sleep ds 
  ON gs2.id = ds.id
UNION ALL
SELECT
  Group 3: <90%' AS group_name,
  COUNT(DISTINCT CASE WHEN ds.id IS NOT NULL THEN gs3.id END) AS count_with_entry,
  COUNT(DISTINCT CASE WHEN ds.id IS NULL THEN gs3.id END) AS count_without_entry
FROM Capstone.group3_less27days gs3
LEFT JOIN Capstone.daily_sleep ds 
  ON gs3.id = ds.id;
```


```markdown
-- Average calories and steps for the 3 groups
-- Calculate the average of Calories and TotalSteps for group1_31days
SELECT 
  AVG(Calories) AS Average_Calories, 
  AVG(TotalSteps) AS Average_TotalSteps
FROM Capstone.group1_31days
UNION ALL
-- Calculate the average of Calories and TotalSteps for group2_28to30days
SELECT 
  AVG(Calories) AS Average_Calories, 
  AVG(TotalSteps) AS Average_TotalSteps
FROM Capstone.group2_28to30days
UNION ALL
-- Calculate the average of Calories and TotalSteps for group3_less27days
SELECT 
  AVG(Calories) AS Average_Calories, 
  AVG(TotalSteps) AS Average_TotalSteps
FROM Capstone.group3_less27days;
```


```markdown
-- Average step count for group1 throughout the week by day
SELECT
  FORMAT_TIMESTAMP('%A', ActivityDate) AS DayOfWeek,
  AVG(TotalSteps) AS AverageSteps
FROM `tenacious-text-379818.Capstone.group1_31days`
GROUP BY DayOfWeek
ORDER BY DayOfWeek;
```

```markdown
-- Looking at calories and total steps
SELECT
  Id,
  AVG(TotalSteps) AS average_steps,
  AVG(Calories) AS average_calories
FROM `tenacious-text-379818.Capstone.group1_31days`
GROUP BY Id
```


```markdown
-- Hourly average step count by day for group 1
WITH hourly_avg AS (
  SELECT
    FORMAT_TIMESTAMP('%A', hs.ActivityHour) AS DayOfWeek,
    EXTRACT(HOUR FROM hs.ActivityHour) AS HourOfDay,
    AVG(hs.StepTotal) AS AverageHourlySteps
  FROM `Capstone.hourly_steps` hs
  LEFT JOIN `Capstone.group1_31days` g 
    ON hs.Id = g.Id
  GROUP BY 
    DayOfWeek,
    HourOfDay
  )
SELECT
  HourOfDay,
  AVG(IF(DayOfWeek = 'Monday', AverageHourlySteps, NULL)) AS Monday,
  AVG(IF(DayOfWeek = 'Tuesday', AverageHourlySteps, NULL)) AS Tuesday,
  AVG(IF(DayOfWeek = 'Wednesday', AverageHourlySteps, NULL)) AS Wednesday,
  AVG(IF(DayOfWeek = 'Thursday', AverageHourlySteps, NULL)) AS Thursday,
  AVG(IF(DayOfWeek = 'Friday', AverageHourlySteps, NULL)) AS Friday,
  AVG(IF(DayOfWeek = 'Saturday', AverageHourlySteps, NULL)) AS Saturday,
  AVG(IF(DayOfWeek = 'Sunday', AverageHourlySteps, NULL)) AS Sunday
FROM hourly_avg
GROUP BY HourOfDay
ORDER BY HourOfDay
```
